# 2. Выполнить логические побитовые операции «И», «ИЛИ» и др. над числами 5 и 6.
# Выполнить над числом 5 побитовый сдвиг вправо и влево на два знака.
# Объяснить полученный результат.

a = 5
print(f'{a} = {bin(a)}')
b = 6
print(f'{a} = {bin(a)}')
# Побитовое AND
# Значение бита равно 1, если соответствующие биты в операндах также равны 1.
# Во всех остальных случаях значение результирующего бита равно 0
# 0101 AND 0110 = 0100  или 4
print(f'{a} and {b} = {a & b}({bin(a & b)})')

# Побитвое OR
# Результирующий бит равен 1, если соответствующий бит в любом из операторов равен 1
# 0101 AND 0110 = 0111  или 7
print(f'{a} or {b} = {a | b}({bin(a | b)})')

# Побитовое XOR
# Результирующий бит равен 1, если соответствующий бит только в одном из операндов равен 1.
# 0101 AND 0110 = 0011  или 3
print(f'{a} xor {b} = {a ^ b}({bin(a ^ b)})')
# Побитовое NOT интвертирует все биты операнда, добавляет один бит знака, из-за особенностей языка python
# инвертировать будет |a - (-0.50| относительно -0.5, а не нуля. То есть 5 - (-0.5) = 5,5 и относительно -0,5 это бует
# -0,5 - 5,5 = -6, для b = 6: -0,5 - |6 - (-0,5)| = -7

print(f'not {a} = {~a}({bin(~a)})')
print(f'not {b} = {~b}({bin(~b)})')

# сдвиг 5 влево на 2 добавляет 2 цифры  из 0 и 1, вправо -- убирает
print(f'{a} >> 2 = {a >> 2}({bin(a >> 2)})')
print(f'{a} << 2 = {a << 2}({bin(a << 2)})')


